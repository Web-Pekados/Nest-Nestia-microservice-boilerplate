/**
 * @packageDocumentation
 * @module api.functional
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from '@nestia/fetcher'
import { PlainFetcher } from '@nestia/fetcher/lib/PlainFetcher'
import type { Driver } from 'tgrid'
import { WebSocketConnector } from 'tgrid'

import type { HelloQuery } from '../structures/HelloQuery'
import type { HelloResponse } from '../structures/HelloResponse'
import type { NestListener } from '../structures/NestListener'
import type { PowerRequest } from '../structures/PowerRequest'
import type { PowerResponse } from '../structures/PowerResponse'
import type { RemoteListener } from '../structures/RemoteListener'

export * as health from './health/index'
export * as post from './post/index'

/**
 *
 * @summary Connect to the WebSocket server
 * @tag WebSocketRpc
 *
 * @controller WebSocketRpcController.connect
 * @path /connect
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function connect(
  connection: IConnection<connect.Header>,
  provider: connect.Provider,
): Promise<connect.Output> {
  const url: string = `${connection.host.endsWith('/') ? connection.host.substring(0, connection.host.length - 1) : connection.host}${connect.path()}`
  const connector: WebSocketConnector<
    connect.Header,
    connect.Provider,
    connect.Listener
  > = new WebSocketConnector(connection.headers ?? ({} as any), provider)
  await connector.connect(url)
  const driver: Driver<connect.Listener> = connector.getDriver()
  return {
    connector,
    driver,
    reconnect: async () => await connector.connect(url),
  }
}
export namespace connect {
  export type Output = {
    connector: WebSocketConnector<Header, Provider, Listener>
    driver: Driver<Listener>
    reconnect: () => Promise<void>
  }
  export type Header = any
  export type Provider = RemoteListener
  export type Listener = NestListener

  export const path = () => '/connect'
}

/**
 * It can be used to store multiline method<br/>
 * with HTML markup
 *
 * @summary The description line shown in the endpoints list
 * @returns Newly archived article
 * @tag Demo Some description describing demo group...
 * @operationId getHello
 * @security bearer
 *
 * @controller ExampleController.getHello
 * @path GET /
 * @accessor api.functional.getHello
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getHello(
  connection: IConnection,
  { text, num }: getHello.Query,
): Promise<getHello.Output> {
  return PlainFetcher.fetch(connection, {
    ...getHello.METADATA,
    template: getHello.METADATA.path,
    path: getHello.path({ text, num }),
  })
}
export namespace getHello {
  export type Query = HelloQuery
  export type Output = HelloResponse

  export const METADATA = {
    method: 'GET',
    path: '/',
    request: null,
    response: {
      type: 'application/json',
      encrypted: false,
    },
    status: 200,
  } as const

  export const path = ({ text, num }: Query) => {
    const variables: URLSearchParams = new URLSearchParams()
    for (const [key, value] of Object.entries({ text, num } as any))
      if (undefined === value) continue
      else if (Array.isArray(value))
        value.forEach((elem: any) => variables.append(key, String(elem)))
      else variables.set(key, String(value))
    const location: string = '/'
    return 0 === variables.size
      ? location
      : `${location}?${variables.toString()}`
  }
}

/**
 * @operationId power
 * @tag Demo
 * @security bearer
 * @controller ExampleController.power
 * @path POST /
 * @accessor api.functional.power
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function power(
  connection: IConnection,
  body: power.Body,
): Promise<power.Output> {
  return PlainFetcher.fetch(
    {
      ...connection,
      headers: {
        ...connection.headers,
        'Content-Type': 'application/json',
      },
    },
    {
      ...power.METADATA,
      template: power.METADATA.path,
      path: power.path(),
    },
    body,
  )
}
export namespace power {
  export type Body = PowerRequest
  export type Output = PowerResponse

  export const METADATA = {
    method: 'POST',
    path: '/',
    request: {
      type: 'application/json',
      encrypted: false,
    },
    response: {
      type: 'application/json',
      encrypted: false,
    },
    status: 201,
  } as const

  export const path = () => '/'
}
